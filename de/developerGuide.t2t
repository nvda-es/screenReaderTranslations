NVDA NVDA_VERSION Entwicklerhandbuch


%!includeconf: ../userGuide.t2tconf

% Remove double spacing from the beginning of each line as txt2tags seems to indent preformatted text by two spaces
%!PostProc(html): '^  ' ''

= Inhaltsverzeichnis =[toc]
%%toc

+ Einleitung +
Dieses Entwicklerhandbuch enthält Informationen über die Entwicklung von NVDA, einschließlich der Übersetzung und der Entwicklung von Komponenten für NVDA.

++ Eine Anmerkung zu Python ++
NVDA und dessen Komponenten sind hauptsächlich in der Programmiersprache Python geschrieben.
Das Ziel dieses Leitfadens ist nicht, Ihnen Python beizubringen, obwohl in diesem Leitfaden Beispiele aufgeführt sind, die Ihnen helfen werden, sich mit der Python-Syntax vertraut zu machen.
Weitere Dokumentation und andere Ressourcen im Zusammenhang mit der Sprache Python finden Sie auf den Seiten der [Python Software Foundation https://www.python.org/].


+ Übersetzung +
Um mehrere Sprachräume bzw. Sprachen zu unterstützen, muss NVDA übersetzt und die für das Gebietsschema spezifischen Daten bereitgestellt werden.
Dieser Abschnitt enthält lediglich Informationen über benutzerdefinierte NVDA-Dateiformate, die für die Übersetzung erforderlich sind.
Andere Teile von NVDA, wie zum Beispiel die Benutzeroberfläche oder die Dokumentation verwenden Standard-Dateiformate.
Weitere Informationen zu NVDA-Übersetzung finden Sie auf im [GitHub-Wiki https://github.com/nvaccess/nvda/wiki/Translating] von NV Access.

++ Beschreibungen diverser Zeichen ++
Manchmal kann es sehr schwierig oder sogar unmöglich sein, ein Zeichen von einem anderen zu unterscheiden.
Zwei Zeichen können beispielsweise auf die gleiche Weise ausgesprochen werden, obwohl es sich eigentlich um verschiedene Zeichen handelt.
Um den Benutzern in diesem Fall zu helfen, können Beschreibungen solcher Zeichen bereitgestellt werden, die das Zeichen auf eindeutige Weise erklären.

Zeichenbeschreibungen können für ein Gebietsschema in einer Datei namens "characterDescriptions.dic" im Verzeichnis für das Gebietsschema bereitgestellt werden.
Dies ist eine Textdatei im UTF-8-Format.
Leerzeilen und Zeilen, die mit einem Kommentarzeichen "#" beginnen, werden ignoriert.
Alle anderen Zeilen müssen ein Zeichen enthalten, gefolgt von einem Tabulatorzeichen, dann eine oder mehrere Beschreibungen, die durch Tabs getrennt sind.

zum Beispiel:
```
# Dies ist eine Kommentarzeile
a	Anton
b	Berta
```

Beispiele finden Sie in der Datei "locale\de\characterDescriptions.dic".

In den meisten Fällen sollten die Zeichen in dieser Datei ein einzelnes Zeichen in Kleinbuchstaben sein.
Es wird davon ausgegangen, dass Zeichen unabhängig von ihrem Fall die gleiche Beschreibung haben, so dass Großbuchstaben in Kleinbuchstaben umgewandelt werden, bevor die jeweilige Beschreibung erfolgt.

++ Aussprache von Symbolen ++
Es ist oft nützlich, Satzzeichen und andere Symbole zu hören, die beim Lesen von Texten als Wörter ausgesprochen werden, insbesondere beim Navigieren der einzelnen Zeichen.
Unglücklicherweise ist die Aussprache von Symbolen zwischen Sprachausgaben nicht einheitlich und manche können viele Symbole gar nicht aussprechen oder erlauben keine Kontrolle darüber, welche Symbole wie ausgesprochen werden.
Aus diesem Grund gibt es die Möglichkeit in NVDA die Bereitstellung von Informationen über die Aussprache von Symbolen.

Dies geschieht für ein Gebietsschema, indem eine Datei namens "symbols.dic" im Verzeichnis für das Gebietsschema bereitgestellt wird.
Dies ist eine Textdatei im UTF-8-Format.
Leerzeilen und Zeilen, die mit einem Kommentarzeichen "#" beginnen, werden ignoriert.
Alle Gebietsschema übernehmen die Aussprache der Symbole und Zeichen aus dem Englischen, die aber im Gebietsschema zur Übersetzung überschrieben werden können.

Die Datei enthält zwei Abschnitte:

+++ Komplexe Symbole definieren +++
Der erste Abschnitt ist optional und enthält Definitionen komplexer Symbole in Form regulärer Ausdrücke.
Komplexe Symbole sind nicht einfach nur Sonderzeichen oder Sequenzen von Sonderzeichen, die durch Wörter ersetzt werden sollen. Stattdessen erfordern sie eine kompliziertere Überprüfung auf Übereinstimmung.
Ein Beispiel ist der Punkt (.) als Satzzeichen am Ende eines Satzes.
Da der Punkt "." mehrere Bedeutungen hat, daher ist eine kompliziertere Prüfung erforderlich, um festzustellen, ob es sich um das Ende eines Satzes handelt.

Der Abschnitt für komplexe Symbole beginnt mit der folgenden Zeile:
```
complexSymbols:
```

Nachfolgende Zeilen enthalten eine Bezeichnung, der zur Identifizierung des Symbols verwendet wird, ein Tabulatorzeichen und das Muster für den regulären Ausdruck für dieses Symbol.
Zum Beispiel:
```
. Satzpunkt	(?<=[^\s.])\.(?=[\"')\s]|$)
```

Da jeder Sprachraum die komplexen Symbole des englischen Sprachraumes übernimmt, brauchen Sie diese in Ihrer Symboldefinition nicht noch einmal aufzuführen.

+++ Symbol-Informationen definieren +++
Der zweite Abschnitt enthält Informationen darüber, wann und wie alle Symbole ausgesprochen werden sollen.
Es beginnt mit der Zeile:
```
symbols:
```

Nachfolgende Zeilen enthalten mehrere Felder, die durch Tabulatorzeichen getrennt werden.
Die einzigen Pflichtfelder sind der Name des Symbols und die entsprechende Beschriftung dazu.
Für nicht mit angegebene Felder wird die Standard-einstellung verwendet.
Die Felder sind wie folgt:
- name: Der Name eines Symbols.
In den meisten Fällen ist es nur das Zeichen oder das Zeichen des Symbols selbst.
Es kann aber auch der Name eines komplexen Symbols sein.
Bestimmte Zeichen können nicht in die Datei eingegeben werden, so dass die folgenden speziellen Sequenzen verwendet werden müssen:
 - \0: Null
 - \t: Tabulator
 - \n: Zeilenumbruch
 - \r: Wagenrücklauf
 - \f: Seitenvorschub
 - \#: #-Zeichen (benötigt, da das "#" am Zeilenanfang ansonsten ein Kommentar darstellt)
- Bezeichnung: Der Text, der für das Symbol gesprochen werden soll.
- Stufe: Die Symbolstufe, ab der das Symbol gesprochen werden soll.
Die Symbolstufe wird vom Benutzer konfiguriert und gibt die Anzahl der Symbole an, die gesprochen werden sollen.
Dieses Feld sollte eine der folgenden Stufen "none", "some", "most", "all" oder "char" oder "-" sein, um den Standard zu verwenden.
"char" bedeutet, dass das Symbol nur dann ausgesprochen werden sollte, wenn der Benutzer zeichenweise navigiert.
Die Vorgabe kann den Wert selbst oder den Wert "all" haben, wenn nichts übernommen werden kann.
- preserved: Ob das Symbol selbst erhalten bleibt, um die korrekte Aussprache durch die Sprachausgabe zu erleichtern.
Beispielsweise sollten Symbole, die Pausen oder Beugungen verursachen (z. B. das Komma), beibehalten werden.
Dieses Feld sollte eines der Folgenden sein:
 - never: Das Symbol wird nie beibehalten.
 - always: Das Symbol wird immer beibehalten.
 - norep: Das Symbol nur dann beibehalten, wenn es nicht ersetzt wird, d. h. der Benutzer hat die Symbolstufe niedriger eingestellt als die Stufe dieses Symbols.
 - -: Verwendet den Standardwert.
 -
Die Standard-Vorgabe ist, den Wert zu übernehmen oder "none", wenn es nichts zu übernehmen gibt.
-

Schließlich kann in einem Kommentar nach einem Tabulatorzeichen am Zeilenende ein Anzeigename für das Symbol angegeben werden.
Dies wird dem Benutzer bei der Bearbeitung der Symbol-Informationen angezeigt und ist besonders hilfreich für Übersetzer, um übersetzte Namen für komplexe Symbole aus dem Englischen zu definieren.

Hierzu einige Beispiele:
```
(	Runde Klammer auf	most
```
Das bedeutet, dass das Zeichen "(" nur dann als "Runde Klammer auf" gesprochen werden soll, wenn die Symbolstufe auf die höchste oder nächsthöhere Stufe gesetzt ist, d. h. "most" oder "all".
```
,	Komma	all	always
```
Dies bedeutet, dass das Zeichen "," als "Komma" gesprochen werden soll, wenn als Satzzeichenebene und Symbolstufe auf "all" eingestellt ist. Außerdem wird das Zeichen immer unverändert an die Sprachausgabe übergeben, um Sprechpausen korrekt zu setzen.
```
. Satzpunkt	Punkt	# . fin de phrase
```
Diese Zeile stammt aus der französischen Datei "symbols.dic".
Es bedeutet, dass das komplexe Symbol ". Satzpunkt" als "Punkt" gesprochen werden soll.
Stufe und Einstellung zum Beibehalten des Symbols sind hier nicht angegeben, werden also aus dem Englischen übernommen.
Ein anzeigename wird ebenfalls angegeben, sodass französische NVDA-Anwender wissen, was dieses Symbol bedeutet.

Bitte beachten Sie die Datei "locale\en\symbols.dic" für die englischen Definitionen, die für alle Gebitsschemata verwendet werden.
Dies ist auch ein gutes Beispiel.

+ Erweiterungen +

++ Übersicht ++
Erweiterungen ermöglichen es Ihnen, das Verhalten von NVDA insgesamt oder innerhalb einer bestimmten Anwendung anzupassen.
Hierzu zählen z. B.:
- Auf bestimmte Ereignisse reagieren, wenn sich zum Beispiel der Fokus verschiebt oder wenn sich die Eigenschaften eines Objekts ändern.
- Befehle implementieren, die an bestimmte Tastendrücke oder andere Eingabemethoden gebunden werden können.
- Das Verhalten bestimmter Steuerelemente beeinflussen oder weitere Funktionen hinzufügen.
- Unterstützung für Textinhalte oder komplexe Dokumente anpassen oder hinzufügen.
-

Dieser Abschnitt enthält lediglich eine Einführung in die Entwicklung von Erweiterungen.
Schauen Sie sich die Code-Dokumentation für eine komplette Referenz an.

++ Typen von Modulen ++
Es gibt zwei unterschiedliche Typen von Modulen:
- Anwendungsmodul: Enthalten speziellen Code für eine bestimmte Anwendung.
Ein Anwendungsmodul nimmt Ereignisse für eine bestimmte Anwendung entgegen, auch wenn die Anwendung momentan nicht im Vordergrund sich befindet.
Wenn eine Anwendung sich im Vordergrund befindet, kann der Benutzer sämtliche Befehle ausführen, die im Anwendungsmodul definiert und an Eingabemethoden zugewiesen wurden.
- Allgemeine Module: Enthalten Code, der in allen Anwendungen ausgeführt wird.
Dabei nehmen sie alle Ereignisse von allen Elementen im Betriebssystem entgegen.
Befehle, die in allgemeinen Erweiterungen an Eingabemethoden zugewiesen wurden, können unabhängig davon ausgeführt werden, welche Anwendung grade aktiv ist.
-

Wenn Sie vorhaben, die Zugänglichkeit von NVDA für bestimmte Anwendungen zu verbessern, ist ein "appModule" empfehlenswert.
Wenn Sie im Gegensatz dazu vorhaben, globalen Code für NVDA zu entwickeln, der systemweit zugänglich sein soll, zum Beispiel um sich die Signalstärke von Funknetzwerken anzeigen zu lassen, ist eine "globalPlugin" empfehlenswert.

Diese sind sehr ähnlich.
Beides sind Python-Quelldateien (mit der Erweiterung ".py") und definieren beide eine spezielle Klasse, die alle Ereignisse, Skripte und Verknüpfungen enthält, und sie können beide benutzerdefinierte Klassen für Zugriffskontrollen, Textinhalte und komplexe Dokumente definieren.
Sie unterscheiden sich jedoch in mancher Hinsicht.

Benutzerdefinierte Anwendungsmodule und allgemeine Module können in NVDA-Erweiterungspakete verpackt werden. 
Dies ermöglicht eine einfache Verteilung und bietet dem Benutzer eine sichere Möglichkeit, den benutzerdefinierten Code zu installieren und wieder zu deinstallieren.
Bitte beachten Sie den Abschnitt zu Erweiterungen weiter unten in diesem Dokument.

Um den Code während der Entwicklung zu testen, können Sie ihn in ein spezielles "scratchpad"-Verzeichnis in Ihrem NVDA-Benutzerkonfigurationsverzeichnis abspeichern.
Sie müssen NVDA auch so konfigurieren, dass benutzerdefinierter Code aus dem Entwickler-Scratchpad-Verzeichnis geladen werden kann, indem Sie dies in der Kategorie "Erweitert" im Dialogfeld NVDA-Einstellungen aktivieren.
Die Kategorie "Erweitert" enthält auch eine Schaltfläche zum einfachen Öffnen des Developer Scratchpad-Verzeichnisses, falls aktiviert.

In den folgenden Abschnitten wird separat auf Anwendungsmodule und allgemeine Module eingegangen.
Nach diesem Punkt ist das Thema wieder allgemeiner.

++ Grundlagen eines Anwendungsmoduls ++
Anwendungsmodule ("appModule") besitzen die Endung ".py" und haben den gleichen Namen wie die Anwendungen, für die sie verwendet werden sollen.
Ein Anwendungsmodul für den Editor müsste zum Beispiel "notepad.py" lauten, weil die ausführbare Datei des Editors notepad.exe heißt.

Anwendungsmodule müssen im Unterordner "appModules" der Benutzerkonfiguration von NVDA liegen.
Weitere Informationen über den Standort Ihres benutzerspezifischen Konfigurationsverzeichnisses finden Sie im Benutzerhandbuch von NVDA.

Anwendungsmodule müssen eine Klasse "appModule" definieren, die alle Eigenschaften und Methoden von appModuleHandler.AppModule erbt.
Diese Klasse kann dann Ereignisse, Skripte, Eingabemethodenzuweisungen und anderen Code enthalten.
Details hierzu lesen Sie weiter unten.

Sobald NVDA erkennt, dass eine bestimmte Anwendung gestartet wird, wird das jeweilige Anwendungsmodul geladen.
Wenn die betreffende Anwendung oder NVDA beendet wird, wird auch das Anwendungsmodul wieder aus dem Speicher entfernt.

++ Beispiel 1: Ein Anwendungsmodul erzeugt Signaltöne, wenn sich der Fokus verändert ++[Example1]
Das folgende Anwendungsmodul gibt jedes mal einen Signalton wieder, wenn sich innerhalb des Editors der Fokus ändert.
Dieses Beispiel veranschaulicht den grundsätzlichen Aufbau eines solchen Anwendungsmoduls.

Fügen Sie den Folgenden Code zwischen den Start- und Endmarken (jedoch nicht die Marken selbst) in eine Datei mit dem Namen "notepad.py" ein und speichern Sie diese im Unterverzeichnis appmodules in ihrer benutzerspezifischen nvda-Konfiguration.
Übernehmen Sie hierbei auch alle Tab- und Leerzeichen.

Starten Sie anschließend NVDA neu oder wählen Sie "Erweiterungen neu laden" aus dem Menü "Werkzeuge" aus, damit die Änderungen wirksam werden.

Öffnen Sie dann den Editor und bewegen Sie den Fokus innerhalb der Anwendung (z. B. innerhalb des Menüs, innerhalb von Dialogfeldern, etc.).
Sie sollten nun jedes Mal einen Signalton hören, wenn sich der Fokus ändert.
Beachten Sie jedoch, dass Sie, wenn Sie sich außerhalb des Notepads bewegen - z. B. in den Windows Explorer - keine Signaltöne mehr hören.

```
--- Anfang des Code-Blocks ---
# Notepad-Anwendungsmodul für NVDA
# Beispiel 1 aus dem Entwicklerhandbuch

import appModuleHandler

class AppModule(appModuleHandler.AppModule):

	def event_gainFocus(self, obj, nextHandler):
		import tones
		tones.beep(550, 50)
		nextHandler()

--- Ende des Code-Blocks ---
```

Dieses Anwendungsmodul beginnt mit zwei Kommentarzeilen, die den Zweck des Anwendungsmoduls beschreiben.

Anschließend wird das Modul "appmoduleHandler" importiert, welches die Basisklasse für Anwendungsmodule zur Verfügung stellt.

Als nächstes wird eine Klasse namens AppModule definiert, die von appModuleHandler.AppModule abgeleitet ist.

Innerhalb der Klasse werden ein oder mehr Ereignisse, Skripte oder Zuweisungen für Eingabemethoden definiert.
Dieses Beispiel definiert ein Ereignis namens "gainfocus(event_gainFocus)", das bei jeder Ausführung einen kurzen Signalton abspielt.
Die Implementierung dieses Ereignisses ist für die Zwecke dieses Beispiels nicht von Bedeutung.
Wichtig ist nur der Teil innerhalb der Klasse.
Ereignisse werden weiter unten in diesem Handbuch näher erläutert.

Wie bei anderen Beispielen in diesem Handbuch, denken Sie daran, das erstellte Anwendungsmodul zu löschen, wenn Sie mit dem Testen fertig sind und starten Sie dann NVDA neu oder laden Sie das Modul neu, damit die ursprüngliche Funktionalität wiederhergestellt wird.

++ Grundlagen von allgemeinen Modulen ++
Allgemeine Module sollten die Endung ".py" besitzen und einen kurzen Namen haben, der ihren Zweck beschreibt.

Diese Dateien müssen im Unterverzeichnis "globalPlugins" einer Erweiterung oder im "Developer Scratchpad"-Verzeichnis des NVDA-Benutzerkonfigurationsverzeichnisses abgelegt werden.

Diese Module müssen eine Klasse namens "globalPlugin" definieren, die von "globalPluginHandler.GlobalPlugin" erbt.
Diese Klasse kann dann Ereignis- und Skriptmethoden, Gesten und anderen Code definieren.
Dies alles wird später ausführlich behandelt.

NVDA lädt alle allgemeinen Module, sobald es gestartet wird und entlädt sie beim Beenden wieder.

++ Beispiel 2: Ein allgemeines Modul - Ein Skript zur Ansage der NVDA-Version ++
Das folgende Modul-Beispiel ermöglicht es Ihnen, NVDA+Umschalt+V zu drücken, während Sie sich irgendwo im Betriebssystem befinden, um die NVDA-Version herauszufinden.
Das Beispiel dient lediglich dazu, den grundlegenden Aufbau globaler Erweiterungen zu veranschaulichen.

Kopieren Sie den folgenden Text zwischen den Anfangs- und Endmarkern (jedoch nicht die Marker selbst), in eine Datei namens "beispiel2.py" und speichern Sie diese im Unterordner "globalPlugins" Ihres NVDA-Konfigurationsverzeichnisses.
Lassen Sie dabei alle Tabulatorzeichen und Leerzeichen stehen.

Starten Sie nach dem Speichern entweder NVDA neu oder wählen aus dem Menü "Werkzeuge" des NVDA-Menüs den Befehl "Module neu laden" aus.

Von nun an können Sie NVDA+Umschalt+V drücken, um die NVDA-Version angesagt und in Braille angezeigt zu bekommen.

```
--- Anfang des Code-Blocks ---
# Modul zur Ausgabe der Versionsinformationen in NVDA
# Beispiel 2 aus dem Entwicklerhandbuch

import globalPluginHandler
from scriptHandler import script
import ui
import versionInfo

class GlobalPlugin(globalPluginHandler.GlobalPlugin):

	@script(gesture="kb:NVDA+shift+v")
	def script_announceNVDAVersion(self, gesture):
		ui.message(versionInfo.version)

--- Ende des Code-Blocks ---
```

Dieses Modul beginnt mit zwei Kommentarzeilen, die den Zweck der Datei kurz beschreibt.

Anschließend wird das Modul "globalPluginHandler" importiert, sodass das Modul Zugriff auf die Basisklasse "globalPlugin" hat.

Außerdem werden noch die Module "UI" und "Versioninfo" importiert, damit die Erweiterung die Versionsinformationen ausgeben kann.

Als nächstes wird eine Klasse "globalPlugin" definiert, die ein Nachkomme von "globalPluginHandler.GlobalPlugin" ist.

Innerhalb dieser Klasse werden ein oder mehrere Ereignisse, Skripte oder Eingabemethoden-Zuweisungen definiert.
In diesem Beispiel enthält die Klasse ein Skript, das die Versionsinformationen ausgibt und eine eingabemethoden-Zuweisung, die dieses Skript an NVDA+Umschalt+V zuweist.
Die Details des Skripts und der Eingabemethodenzuweisung sind für dieses Beispiel jedoch nicht von Belang.
Wichtig ist die Klasse selbst.
Weitere Informationen zu Skripten und dem Skriptdekorateur finden Sie im Abschnitt [Skripteigenschaften definieren #DefinitionScriptProperties] dieses Handbuchs.

Um das ursprüngliche Verhalten von NVDA wiederherzustellen, müssen Sie die Datei löschen und NVDA anschließend neu starten oder die Erweiterungen neu laden.

++ NVDA-Objekte ++
NVDA stellt Steuerelemente und andere Bestandteile von Benutzeroberflächen in Form von NVDA-Objekten dar.
Diese Objekte enthalten standardisierte Eigenschaften wie name, Typ, Wert, Status und Beschreibung. Dies erlaubt anderen Teilen von NVDA, diese Informationen über ein Objekt in verallgemeinerter Form abzufragen oder darzustellen.
Die Schaltfläche "OK" in einem Dialogfeld wird beispielsweise den Namen "OK" und den Steuerelementtyp "Schaltfläche" besitzen.
So ähnlich würde beispielsweise ein Kontrollkästchen mit der Beschriftung "Ich stimme zu" den Namen "Ich stimme zu", den Typ Kontrollkästchen und - falls aktiviert - den Status aktiviert besitzen.

Auch wenn es unterschiedliche Komponentenbausätze für Benutzeroberflächen und Zugänglichkeitsschnittstellen gibt, abstrahieren NVDA-Objekte diese unterschiede zu einer einheitlichen Form, gleichgültig, mit welchem Komponentenbausatz ein Steuerelement erzeugt wurde oder über welche Zugänglichkeitsschnittstelle darauf zugegriffen wird.
Der oben angesprochene Schalter "OK" könnte also beispielsweise ein Java-Objekt sein. Genauso gut könnte er aber auch ein MSAA-Objekt, ein iAccessible2-Objekt oder ein UIA-Element sein.

NVDA-Objekte haben viele Eigenschaften.
Einige der Nützlichsten sind:
- name: Die Beschriftung des Steuerelements
- role: Der Typ des Steuerelements, repräsentiert durch eine der ROLE_*-Konstanten aus dem Modul controltypes.
Schaltfläche, Dialogfeld, Eingabefeld, Fenster und Kontrollkästchen sind nur einige Beispiele für Steuerelementtypen.
- states: Status des Steuerelements, repräsentiert durch einen Satz von 0 oder mehr STATE_*-Konstanten aus dem Modul controltypes.
Hervorhebbar, hervorgehoben, ausgewählt, auswählbar, erweitert, reduziert und aktiviert sind nur einige Beispiele für den Status.
- value: Der Wert des Steuerelements, z. B. der aktuelle Stand einer Fortschrittsanzeige oder der aktuelle gewählte Eintrag in einem Kombinationsfeld.
- description: Eine kurze Beschreibung, die den Zweck des Steuerelements erläutert (üblicherweise identisch mit der Minihilfe).
- location: Der Abstand eines Objektes von der oberen linken Ecke des Bildschirms sowie dessen Breite und Höhe in Form von Bildschirmkoordinaten.
- parent: Das übergeordnete Objekt.
Das übergeordnete Objekt eines Listeneintrags ist beispielsweise die Liste, die ihn enthält.
- next: Das nächste Objekt in der logischen Reihenfolge
- previous: Das vorherige Objekt in der logischen Reihenfolge
- firstChild: Das erste direkt untergeordnete Objekt.
Das erste, untergeordnete Objekt einer Liste ist beispielsweise deren erster Eintrag.
- lastChild: Das letzte untergeordnete Objekt eines Objekts.
- children: Eine Liste aller untergeordneten Objekte eines Objekts (beispielsweise alle Einträge eines Menüs).
-

Es gibt auch noch Eigenschaften, die sich auf die vereinfachte Navigation beziehen wie "simpleParent", "simpleNext", "simpleFirstChild" und "simpleLastChild".
Diese entsprechen den oben beschriebenen Eigenschaften, NVDA filtert hier jedoch nutzlose Objekte aus.
Diese eigenschaften werden immer dann verwendet, wenn der vereinfachte Darstellungsmodus in NVDA aktiviert ist, was der Normalfall ist.
Die vereinfachten Eigenschaften sind zwar leichter zu verwenden, die komplexeren Eigenschaften spiegeln jedoch diezugrundeliegende Objektstruktur des Betriebsystems wesentlich besser wieder.
Auch diese können sich in zukünftigen Versionen von NVDA ändern, da Verbesserungen bei der einfachen Überprüfung vorgenommen werden, so dass sie bei der programmatischen Lokalisierung bestimmter Objekte generell vermieden werden sollten.

Bei der Entwicklung von Modulen ist es meist egal, welches Toolkit oder welche API ein NVDA-Objekt unterstützt, da es in der Regel nur auf Standardeigenschaften wie Name, Rolle und Wert zugreift. 
Da Module jedoch immer fortschrittlicher werden, ist es sicherlich möglich, tiefer in NVDA-Objekte einzutauchen, um bei Bedarf Toolkit- oder API-spezifische Informationen herauszufinden.

Es gibt drei Möglichkeiten, wie Module NVDA-Objekte verwenden können:
- Die meisten Ereignisse verarbeiten ein Argument, das dasjenige Objekt angibt, auf das sich das Ereignis bezieht.
Das Ereignis "event_gainfocus" übernimmt beispielsweise dasjenige Objekt als Parameter, das soeben den Fokus bekommen hat.
- Skripte und Ereignisse können Objekte verarbeiten, wie z. B. das aktuell hervorgehobene Objekt, das aktuelle navigatorobjekt oder den Desktop.
Anschließend könnten auf andere Objekte bezug genommen und Informationen von ihnen abgerufen werden.
- Das Modul könnte auch eine eigene NVDA-Objektklasse definieren, um ein bestimmtes Steuerelement darin einzuschließen. Solche benutzerdefinierten NVDA-Objekte können einem NVDA-Objekt neue Funktionalität geben, dessen Eigenschaften umwandeln, etc.
-

Ebenso wie Anwendungsmodule oder allgemeine Module können NVDA-Objekte Skripte, Ereignisse und Eingabemethoden-zuweisungen enthalten.

++ Skripte und Tastenanbindung ++
Anwendungsmodule, allgemeine Module und NVDA-Objekte können Methoden enthalten, die an Ereignisse wie z. B. Tastendrücke zugewiesen werden können.
Auf solche Methoden greift NVDA mittels Skripte zu.

Ein Skript ist eine Standard-Python-Instanzmethode mit einem Namen, der mit "script_" beginnt; z. B. "script_sayDateTime".

Eine Skriptmethode verarbeitet zwei Argumente:
- self: Eine Referenz auf das Anwendungsmodul, allgemeines Modul oder NVDA-Objekt, von dem aus das Skript aufgerufen wird.
- gesture: Ein Eingabemethoden-Objekt, das die Ausführung des Skripts verursacht hat.
-

Neben dem eigentlichen Skript muss noch ein Eingabemethoden-Objekt definiert werden, damit NVDA bekannt ist, durch welches Ereignis das Skript aufgerufen werden soll.

Eine Gesten-Kennung ist eine einfache Zeichenkettendarstellung eines Eingabefeldes.
Es besteht aus einem zweistelligen Zeichencode, der die Quelle der Eingabe angibt, einer optionalen Vorrichtung in Klammern, einem Doppelpunkt (:) und einem oder mehreren Namen, die durch ein Plus (+) getrennt sind, das die tatsächlichen Schlüssel oder Eingabewerte angibt.

Einige Beispiele für solche Gesten sind:
- "kb:NVDA+shift+v"
- "br(freedomScientific):leftWizWheelUp"
- "br(alva.BC640):t3"
- "kb(laptop):NVDA+t"
-

Aktuell werden folgende Eingabequellen unterstützt:
- kb: Tastatureingaben
- br: Steuerungstasten der Braillezeile
- ts: Touchscreen
- bk: Eingabe über die Braille-Tastatur
-

Wenn NVDA eine Tastatureingabe registriert, sucht es in einer bestimmten Reihenfolge nach einer entsprechenden Eingabemethoden-Zuweisung.
Wurde eine Zuweisung gefunden, so wird das entsprechende Skript ausgeführt. Weder wird weiter nach Eingabemethoden-Zuweisungen gesucht, noch wird der Tastendruck ans Betriebssystem weitergereicht.

Folgende Reihenfolge wird bei der Suche nach den Zuweisungen der Eingabemethoden verwendet:
- Die benutzerspezifischen Gesten
- Die sprachspezifischen Gesten
- Die spezifischen Gesten von Treiber der Braillezeilen
- Geladene allgemeiner Module
- Anwendungsmodul der aktiven Anwendung
- Tree Interceptor des NVDA-Objekts mit Fokus, falls vorhanden; z. B. virtualBuffer
- NVDA-Objekt mit Fokus
- Globale Befehle (eingebaute Befehle wie Beenden von NVDA, Objektnavigationsbefehle, etc.)
-

+++ Skript-Eigenschaften definieren +++[DefiningScriptProperties]
Für NVDA 2018.3 und neuer wird empfohlen, die Skript-Eigenschaften mit Hilfe des sogenannten Skript-Dekorators zu setzen.
Kurz gesagt, das ist eine Funktion, die das Verhalten einer bestimmten Funktion anpasst.
Der Skript-Dekorator passt die Schrift so an, dass sie richtig an die gewünschten Gesten gebunden wird.
Außerdem stellt es sicher, dass das Skript mit der von Ihnen angegebenen Beschreibung aufgelistet und im Eingabegesten-Dialog in die gewünschte Kategorie eingeordnet wird.

Damit Sie den Skript-Dekorator verwenden können, müssen Sie ihn aus dem Modul "scriptHandler" importieren.
```
--- Anfang des Code-Blocks ---
from scriptHandler import script
--- Ende des Code-Blocks ---
```

Anschließend fügen Sie direkt über Ihrer Skript-Definition den Skript-Dekorator hinzu und stellen ihm die gewünschten Argumente zur Verfügung.
Beispiel:
```
--- Anfang des Code-Blocks ---
	@script(
		description=_("Datum und Uhrzeit ansagen"),
		category=inputCore.SCRCAT_MISC,
		gestures=["kb:NVDA+shift+t", "kb:NVDA+alt+r"]
	)
	def script_sayDateTime(self, gesture):

--- Ende des Code-Blocks ---
```

In diesem Beispiel wird das Skript im Dialogfeld "Tastenbefehle" unter der Kategorie "Sonstiges" aufgelistet.
Es hat die Bezeichnung "Datum und Uhrzeit ansagen" und ist für die Tastenkombinationen "NVDA+Umschalt+T" und "NVDA+Alt+R" definiert.

Die folgenden Schlüsselwort-Argumente können bei der Anwendung des Skript-Dekorators verwendet werden:
- description: Ein kurzer, übersetzbarer String, der den Befehl für Benutzer beschreibt.
  Dies wird dem Benutzer im Eingabehilfemodus gemeldet und im Dialogfeld "Tastenbefehle" angezeigt.
  Das Skript wird nicht im Dialogfeld "Tastenbefehle" angezeigt, es sei denn, Sie geben eine Beschreibung an.
- category: Die Kategorie des Skripts, damit es mit anderen ähnlichen Skripten gruppiert werden kann.
  Beispielsweise kann ein Skript in einem globalen Modul, das Schnellnavigationstasten für den Lesemodus hinzufügt, unter der Kategorie "Lesemodus" eingeordnet werden.
  Die Kategorie kann für einzelne Skripte gesetzt werden, aber Sie können auch das Attribut "scriptCategory" in der Modul-Klasse setzen, welches für Skripte verwendet wird, die keine Kategorie angegeben haben.
  In den Modulen "inputCore" und "globalCommands" gibt es Konstanten für gängige Kategorien mit dem Präfix "SCRCAT_", die ebenfalls angegeben werden können.
  Das Skript wird unter der angegebenen Kategorie im Dialogfeld "Tastenbefehle" aufgeführt.
  Ist keine Kategorie angegeben, wird das Skript unter "Sonstiges" eingeordnet.
- gesture: Ein String, der eine einzelne Geste enthält, die mit diesem Skript verknüpft ist, z. B. "kb:NVDA+Shift+R".
- gestures: Eine String-Liste von mehreren Gesten, die mit diesem Skript verknüpft sind, z. B. ["kb:NVDA+Shift+R", "kb:NVDA+Alt+T"].
  Wenn sowohl "gesture" und "gestures" angegeben werden, werden sie kombiniert.
  Entweder eine bestimmte Geste oder ein beliebiges Element in den Gesten kann verwendet werden, um das Skript auszuführen.
- canPropagate: Ein boolescher Wert, der angibt, ob dieses Skript auch angewendet werden soll, wenn es zu einem Fokus-Familienobjekt gehört.
  Dies kann z. B. verwendet werden, wenn Sie ein Skript auf ein bestimmtes Vordergrundobjekt oder ein anderes Objekt im Fokus-Familie angeben wollen, welches nicht das aktuelle Fokus-Objekt ist.
  Diese Option ist standardmäßig auf "False" eingestellt.
- bypassInputHelp: Ein Boolean, das angibt, ob dieses Skript bei aktiver Eingabehilfe ausgeführt werden soll.
  Diese Option ist standardmäßig auf "False" eingestellt.
-

Obwohl der Skript-Dekorator den Skript-Definitionsprozess viel einfacher macht, gibt es mehr Möglichkeiten, Gesten zu definieren und Skript-Eigenschaften zu setzen.
Zum Beispiel kann ein spezielles "__gestures" Python-Wörterbuch als Klassenvariable in einem Anwendungsmodul, in einem globalen Modul oder in einem NVDA-Objekt definiert werden.
Dieses Wörterbuch sollte Strings zu Bezeichnungen der Gesten enthalten, die auf den Namen des angeforderten Skripts zeigen, ohne das Präfix "script_".
Sie können auch eine Beschreibung des Skripts im "docstring" der Funktion angeben.
Eine alternative Möglichkeit, die Kategorie des Skripts anzugeben, besteht darin, ein Attribut "category" in der Skript-Funktion auf einen String zu setzen, der den Namen der Kategorie enthält.

++ Beispiel 3: Ein allgemeines Modul zum Aufspüren von FensterKlassen und Steuerelemente ++
Das folgende Modul bewirkt, dass Sie NVDA+Pfeiltaste nach links drücken können, um die Fensterklasse des aktuellen Fensters zu erfahren. Ebenso können Sie NVDA+Pfeiltaste nach rechts drücken, um die Nummer des Steuerelements des aktuellen Objekts zu erfahren.
Das Beispiel veranschaulicht, wie Sie ein Skript und eine Eingabemethodenzuweisung in einer globalen Erweiterung definieren können.

Speichern Sie den Text innerhalb der Start- und Endmarken (jedoch nicht die Marken selbst) in einer Datei "beispiel3.py" im Verzeichnis "globalPlugins" ab.
Achten Sie dabei darauf, alle Tabs und Leerzeichen exakt zu übernehmen.

Starten Sie nach dem Speichern entweder NVDA neu oder wählen Sie im NVDA-Menü den Befehl "Module neu laden" aus dem Menü "Werkzeuge" aus.
```
--- Anfang des Code-Blocks ---
# Hilfs-Skript für NVDA
# Beispiel 3 aus dem Entwicklerhandbuch

import globalPluginHandler
from scriptHandler import script
import ui
import api

class GlobalPlugin(globalPluginHandler.GlobalPlugin):

	@script(
		description=_("Name der Fensterklasse des aktuellen Fokus-Objekts ansagen"),
		gesture="kb:NVDA+leftArrow"
	)
	def script_announceWindowClassName(self, gesture):
		focusObj = api.getFocusObject()
		name = focusObj.name
		windowClassName = focusObj.windowClassName
		ui.message("Klasse für Fenster \"%s\": %s" % (name, windowClassName))

	@script(
		description=_("Gibt die Control-ID des Fensters im aktuellen Fokus-Objekt aus"),
		gesture="kb:NVDA+rightArrow"
	)
	def script_announceWindowControlID(self, gesture):
		focusObj = api.getFocusObject()
		name = focusObj.name
		windowControlID = focusObj.windowControlID
		ui.message("Control-ID für Fenster \"%s\": %d" % (name, windowControlID))

--- Ende des Code-Blocks ---
```

++ Ereignisse ++
Wenn NVDA bestimmte Toolkit-, API- oder Betriebssystemereignisse erkennt, abstrahiert es diese und löst seine eigenen internen Ereignisse auf Module und NVDA-Objekte aus.

Wenn gleich die meisten Ereignisse zu bestimmten NVDA-Objekten gehören (wie z. B. Umbenennungen, Fokus-Erhalt, Status-Änderung, etc.), können sie auf unterschiedlichen Ebenen verarbeitet werden.
Wird ein Ereignis behandelt, so wird es nicht mehr weitergereicht.
Das Weiterreichen des Ereignisses kann jedoch durch Code innerhalb der Ereignisbehandlungsroutine erzwungen werden, falls nötig.

Ereignisse werden in folgender Reihenfolge abgearbeitet:
- Durch geladene globaler Module.
- Durch das Anwendungsmodul, das dem Objekt zugeordnet wurde, bei dem das Ereignis eintrat.
- Durch den Tree Interceptor (falls vorhanden) der dem Objekt zugeordnet wurde, bei dem das Ereignis eintrat.
- Durch das NVDA-Objekt selbst.
-

Ereignisse sind Python-Instanzmethoden, deren namen mit "event_" beginnen, gefolgt von dem Namen des eigentlichen Ereignisses (z. B. "gainFocus").

Diese Ereignismethoden verarbeiten unterschiedliche Argumente, abhängig davon, auf welcher Ebene sie aufgerufen werden.

Wenn ein Ereignis, das sich auf ein NVDA-Objekt bezieht im NVDA-Objekt selbst definiert wird, akzeptiert es ein Argument namens "self", das die Instanz des NVDA-Objekts darstellt.
einige Ereignisse verarbeiten noch zusätzliche Argumente, dies ist allerdings ziemlich selten.

Wird ein Ereignis, das sich auf ein NVDA-Objekt bezieht, in einer globalen Erweiterung, in einem Anwendungsmodul oder in einem Interceptor definiert, verarbeitet es die folgenden Argumente:
- self: Die Instanz des Anwendungsmoduls, des globalen Erweiterungen oder des Interceptors.
- obj: Das NVDA-Objekt, welches das Ereignis ausgelöst hat.
- nextHandler: Eine Funktion, die bei ihrem Aufruf das Ereignis weiter durchreicht.
-

einige häufig verwendete NVDA-Objektereignisse sind:
- foreground: Dieses Objekt wurde zum neuen Vordergrundfenster d.h. zur neuen aktiven Anwendung.
- gainFocus: Das Objekt erhielt soeben den Fokus.
- loseFocus: Das Objekt hat den Fokus verloren.
- nameChange: Das Objekt wurde umbenannt.
- valueChange: In dem Objekt wurde der Wert geändert (z. B., wenn in einem Kombinationsfeld ein neuer Eintrag ausgewählt wurde).
- stateChange: Das Objekt änderte seinen Status (aktivieren / deaktivieren von Kontrollfeldern, etc.).
- caret: Wird ausgelöst, sobald sich der System-Cursor innerhalb des Objektes bewegt.
- locationChange: Wird ausgelöst, sobald ein Objekt physisch auf dem Bildschirm verschoben wird.
-

Es gibt zwar noch viel mehr, die oben aufgeführten Ereignisse sind jedoch die gebräuchlichsten.

Ein Beispiel für eine Ereignisbehandlungsroutine finden Sie im Beispiel 1.

++ Die Schlafmodus-Variable ++
Anwendungsmodule besitzen eine sehr nützliche Eigenschaft namens "sleepmode". Diese Eigenschaft deaktiviert, wenn sie auf "True" gesetzt wird, fast alle Funktionen von NVDA.
Der Schlafmodus ist nützlich für anwendungen, die eigene Bildschirmlese-Funktionen besitzen oder für Spiele, bei denen man volle Kontrolle über die Tastatur benötigt.

Obwohl der Anwender den Schlafmodus mit NVDA+Umschalt+S umschalten kann, kann der Entwickler trotzdem die Standardeinstellung des Schlafmodus vorgeben.
Dies geschied einfach durch setzen der Eigenschaft "sleepMode" auf "True" in der Klasse des Anwendungsmoduls.

++ Beispiel 4: Ein Schlafmodus-Anwendungsmodul ++
Der folgende Code kann kopiert und im Anwendungsmodul-Verzeichnis in einer Datei für eine Anwendung gespeichert werden, für die Sie den Schlafmodus aktivieren möchten.
Die Datei muss die Endung ".py" erhalten.
```
--- Anfang des Code-Blocks ---

import appModuleHandler

class AppModule(appModuleHandler.AppModule):

	sleepMode = True

--- Ende des Code-Blocks---
```

++ Eigene NVDA-Objektklassen erstellen ++
Um die Zugänglichkeit von anwendungen mit NVDA zu verbessern, ist das Definieren von eigenen NVDA-Objektklassen der effektivste Weg.
Dies ermöglicht Ihnen, die gesamte für ein Steuerelement relevante Logik an einer einzigen Stelle zusammenzufassen, anstatt sie auf verschiedene Ereignisse einer Erweiterung aufzuteilen.

die definition einer eigenen Objektklasse erfolgt in zwei Schritten:
- Definieren der NVDA-Objektklasse und deren Skripte, Ereignisse, Eigenschaften und Eingabemethoden-Zuweisungen
- NVDA mitteilen, dass diese Klasse in bestimmten Situationen zu verwenden ist, indem Sie sie mit Hilfe der Methode "chooseNVDAObjectOverlayClasses" auf Ebene einer Erweiterung einbinden.
-

Wenn Sie eigene NVDA-Objektklassen definieren, haben Sie viele NVDA-Objekt-basisklassen zur Auswahl.
Diese Basisklassen enthalten die grundlegene Unterstützung von Betriebssystem- oder Zugänglichkeitsschnittstellen wie win32, MSAA oder Java Access Bridge.
Sie sollten in der benutzerdefinierten Objektklasse üblicherweise die höchste Basisklasse erben.
Wenn Sie beispielsweise eine benutzerdefinierte Fensterklasse bei einem Steuerelement verwenden wollen, dessen Fensterklasse "edit" ist und dessen Steuerelement-ID 15 ist, werden Sie vermutlich von der Klasse "NVDAObjects.Window.Window" ableiten wollen, weil es sich bei dem besagten Objekt um ein Fenster handelt.
so ähnlich werden Sie Ihr Objekt von der Klasse "NVDAObjects.IAccessible.IAccessible" ableiten, wenn Sie nach der Eigenschaft "accrole" suchen wollen.
Außerdem sollten Sie genau wissen, welche Eigenschaften Sie bei Ihrer benutzerdefinierten Klasse überschreiben wollen.
Wenn Sie beispielsweise eine iAccessible-spezifische Eigenschaft wie "shouldAllowIAccessibleFocusEvent" überschreiben wollen, müssen Sie Ihr Objekt von "NVDAObjects.IAccessible.IAccessible" ableiten.

Die Methode "chooseNVDAObjectOverlayClasses" kann in Anwendungsmodulen oder globalen Erweiterungen eingesetzt werden.
Dabei verarbeitet sie drei Argumente:
+ self: Die Instanz des anwendungsmoduls oder des globalen Erweiterungen.
+ obj: Das Objekt, für das eine neue Klasse ausgewählt werden soll.
+ clsList: Eine Python-Liste mit Klassen, die für das Objekt benutzt werden sollen.
+

Innerhalb dieser Methode sollten Sie entscheiden, welche benutzerdefinierte(n) Objektklasse(n) das objekt verwenden soll, indem Sie dessen Eigenschaften prüfen.
Wenn eine benutzerdefinierte Klasse verwendet werden soll, können Sie sie in die Klassenliste (üblicherweise vorn) einfügen. Sie können auch von NVDA ausgewählte Klassen aus der Liste entfernen, dies ist jedoch selten erforderlich.

++ Beispiel 5: Ein Befehl zum Abrufen der Textlänge in einem Eingabefeld unter Verwendung einer eigenen NVDA-Objektklasse ++
Dieses Anwendungsmodul für den Editor stellt einen Befehl bereit, mit dem die Anzahl der Zeichen in einem Eingabefeld abgerufen werden kann.
Dieser kann mit nvda+l aufgerufen werden.
Dieser Befehl ist nur in Eingabefeldern innerhalb des Editors verfügbar.

Speichern Sie den folgenden Code in einer Datei mit dem Namen "notepad.py" in ihrem NVDA-Konfigurationsverzeichnis.
```
--- Anfang des Code-Blocks ---

import appModuleHandler
from scriptHandler import script
from NVDAObjects.IAccessible import IAccessible
import controlTypes
import ui

class AppModule(appModuleHandler.AppModule):

	def chooseNVDAObjectOverlayClasses(self, obj, clsList):
		if obj.windowClassName == "Edit" and obj.role == controlTypes.ROLE_EDITABLETEXT:
			clsList.insert(0, EnhancedEditField)

class EnhancedEditField(IAccessible):

	@script(gesture="kb:NVDA+L")
	def script_reportLength(self, gesture):
		ui.message("%d Zeichen" % len(self.value))

--- Ende des Code_blocks ---
```

++ Kleine Änderungen an einem NVDA-Objekt in einem Anwendungsmodul vornehmen ++
Manchmal möchten Sie vielleicht nur kleine Änderungen an einem NVDA-Objekt in einer Anwendung vornehmen, z. B. den Namen oder die Rolle überschreiben.
In diesen Fällen benötigen Sie nicht die volle Leistung einer benutzerdefinierten NVDA-Objektklasse.
Dazu können Sie das Ereignis "NVDAObject_init" verwenden, das nur in Anwendungsmodulen zur Verfügung steht.

Die Methode "event_NVDAObject_init" benötigt zwei Argumente:
+ self: Die Instanz des Anwendungsmoduls.
+ obj: Das zu initialisierende NVDA-Objekt.
+

Innerhalb dieser Methode können Sie prüfen, ob dieses Objekt relevant ist und dann Eigenschaften entsprechend überschreiben.

++ Beispiel 6: Beschriftung des Notepad-Eingabefeldes mit "event_NVDAObject_init" ++
Dieses Anwendungsmodul für Notepad meldet NVDA zum Eingabefeld von Notepad, welches den Namen "content" trägt.
Das bedeutet, wenn es den Fokus erhält, wird NVDA "Inhalt bearbeiten" ansagen.

Der folgende Code kann kopiert und in eine Textdatei eingefügt werden, die dann im Verzeichnis "appModules" unter dem Namen "notepad.py" gespeichert wird.
```
--- Anfang des Code-Blocks ---

import appModuleHandler
from NVDAObjects.window import Window

class AppModule(appModuleHandler.AppModule):

	def event_NVDAObject_init(self, obj):
		if isinstance(obj, Window) and obj.windowClassName == "bearbeiten" and obj.windowControlID == 15:
			obj.name = "Inhalt"

--- Ende des Code-Blocks ---
```

+ Code als NVDA-Erweiterungspaket verpacken +
Um den Benutzern die gemeinsame Nutzung und Installation von Plugins und Treibern zu erleichtern, können diese in ein einzelnes NVDA-Zusatzpaket gepackt werden, das der Benutzer dann über den Add-On-Manager, der sich im NVDA-Menü unter Tools befindet, in eine Kopie von NVDA installieren kann.
Erweiterungspakete werden seit NVDA 2012.2 unterstützt.
Ein Erweiterungspaket ist einfach ein Zip-Archiv mit der Datei-Erweiterung ".nvda-addon", welches eine Manifest-Datei, optionalen Installations- bzw. Deinstallationsroutine und ein oder mehrere Verzeichnisse mit Modulen und/oder Treibern enthält.

++ Nicht-ASCII-Dateinamen in Zip-Archiven ++
Wenn Ihre Erweiterung Dateien enthält, die Nicht-ASCII-Zeichen (nicht in Englisch) enthalten, sollten Sie das Zip-Archiv so erstellen, dass es UTF-8-Dateinamen verwendet.
Das bedeutet, dass diese Dateien auf allen Systemen korrekt entpackt werden können, unabhängig von der eingestellten Sprache des Systems.
Leider unterstützen viele Packprogramme dies nicht, auch nicht der Windows-Explorer.
Generell muss die Option auch in Archiven, die sie unterstützen, explizit aktiviert werden.
[7-Zip https://www.7-zip.org/] unterstützt dies, obwohl es durch die Angabe des Parameters "cu=on" aktiviert werden muss.

++ Manifest-Dateien ++
Jedes Erweiterungspaket muss eine Manifest-Datei mit dem Namen "manifest.ini" enthalten.
Dies muss eine Textdatei im UTF-8-Format sein.
Diese Manifest-Datei enthält die Informationen wie den Namen, die Version und die Beschreibung der Erweiterung deklarieren.

+++ Verfügbare Felder +++
Obwohl es dringend empfohlen wird, dass Manifest-Dateien alle Felder enthalten, müssen die als obligatorisch gekennzeichneten Felder enthalten sein.
Andernfalls wird die Erweiterung nicht installiert.

- name: Ein kurzer, eindeutiger Name für die Erweiterung. Dieser dient der internen Unterscheidung von Erweiterungen und wird dem Benutzer nicht angezeigt. (obligatorisch)
- summary: Der Name der Erweiterungen, wie er dem Benutzer angezeigt wird. (obligatorisch)
- version: Die Version dieser Erweiterung; z. B. 2.0. (obligatorisch)
- author: Der Autor dieses Add-Ons, vorzugsweise in der Form Vollständiger Name <E-Mail-Adresse>; z.B. Michael Curran <mick@kulgan.net>. (obligatorisch)
- description: Ein oder zwei kurze Sätze, der den Zweck der Erweiterung beschreibt.
- url: Eine Web-Adresse, unter der diese Erweiterung, weitere Informationen und Updates zu finden sind.
- docFileName: Der Dateiname der Dokumentation für diese Erweiterung; z. B. "readme.html". Siehen Sie im Abschnitt [Dokumentation zur Erweiterung #AddonDoc] für weitere Details.
- minimumNVDAVersion: Die minimal erforderliche NVDA-Version, damit diese Erweiterung installiert oder aktiviert werden kann.
  - Beispiel: 2019.1.1
  - Es muss eine dreistellige Versionsnummer sein; z. B. Jahr.Major.Minor sein, oder eine zweistellige Versionsnummer von Jahr.Major. Im zweiten Fall ist Minor auf 0 voreingestellt.
  - Die Standard-Einstellung ist "0.0.0".
  - Die Versionsnummer muss kleiner oder gleich "LastTestedNVDAVersion" sein.
- lastTestedNVDAVersion: Die zuletzt getestete NVDA-Version, mit der diese Erweiterung getestet wurde.
  - Beispiel: 2019.1.0
  - Es muss eine dreistellige Versionsnummer sein; z. B. Jahr.Major.Minor sein, oder eine zweistellige Versionsnummer von Jahr.Major. Im zweiten Fall ist Minor auf 0 voreingestellt.
  - Die Standard-Einstellung ist "0.0.0".
  - Die Versionsnummer muss größer oder gleich "minimumNVDAVersion" sein.
-

Alle Werte werden in Anführungszeichen gesetzt, wie im folgenden Beispiel gezeigt.

Insbesondere "lastTestedNVDAVersion" wird verwendet, um sicherzustellen, dass die Benutzer sicher sein können, eine Erweiterung zu installieren.
Es sichert den Autor der Erweiterung ab, damit Erweiterungen keine Instabilität aufweisen oder Sicherheitslücken darstellen.
Wenn diese nicht zur Verfügung gestellt wird oder kleiner als die aktuelle NVDA-Version ist (ohne Berücksichtigung der minimalen NVDA-Version; z. B. 2018.3.1), kann der Benutzer die Erweiterung nicht installieren.

+++ Eine Beispiel-Manifest-Datei +++
```
--- Anfang des Code-Blocks ---

name = "meineTestErweiterung"
summary = "Eine coole Test-Erweiterung"
version = "1.0"
description = "Ein Beispiel für eine Erweiterung, das zeigt, wie Erweiterungen erstellt werden!"
author = "Michael Curran <mick@kulgan.net>"
url = "https://github.com/nvaccess/nvda"
docFileName = "readme.html"
minimumNVDAVersion = "2018.1.0"
lastTestedNVDAVersion = "2019.1.0"

--- Ende des Code-Blocks ---
``` 

++ Module und Treiber ++
Die folgenden Module und Treiber können in eine Erweiterung eingebunden werden:
- Anwendungsmodule: Gehören ins Verzeichnis "appModules" im Archiv.
- Treiber für Braillezeilen: Gehören ins Verzeichnis "brailleDisplayDrivers" im Archiv.
- Globale Module: Gehören ins Verzeichnis "globalPlugins" im Archiv.
- Treiber für Sprachausgaben: Gehören ins Verzeichnis "synthDrivers" im Archiv.
-

++ Optionaler Code zum Installieren/Deinstallieren ++
Wenn Sie während der Installation oder Deinstallation Ihrer NVDA-Erweiterung Code ausführen müssen (z. B., um Lizenz-Informationen zu überprüfen oder Dateien in einen bestimmten Ordner zu kopieren), können Sie im Archiv eine Python-Datei mit dem Namen "installTasks.py" erstellen, die spezielle Funktionen enthält, die NVDA für die Erweiterung während der Installation oder Deinstallation ausführt.
In dieser Datei sollten Sie vermeiden, nicht unbedingt notwendige Module zu laden, insbesondere Python-C-Erweiterungen oder Programmbibliotheken aus der eigenen Erweiterung, da dies zu einem späteren Entfernen der Erweiterung führen könnte.
Sollte dies dennoch geschehen, wird das Verzeichnis der Erweiterung umbenannt und nach dem nächsten Neustart von NVDA gelöscht.
Schließlich sollte es nicht von der Existenz oder dem Zustand anderer Erweiterungen abhängen sein, da diese möglicherweise nicht installiert sind, bereits entfernt wurden oder noch nicht initialisiert wurden.

+++ Die "onInstall"-Funktion +++
NVDA sucht und führt eine Funktion "onInstall" in Python-Datei "installTasks.py" aus, nachdem es die Erweiterung in NVDA entpackt hat.
Beachten Sie, dass, obwohl die Erweiterung zu diesem Zeitpunkt entpackt wurde, dessen Verzeichnis mit der Endung ".pendingInstall" versehen wird, bis NVDA neu gestartet, das Verzeichnis umbenannt und die Erweiterung wirklich zum ersten Mal geladen wird.
Wenn diese Funktion einen Fehler auslöst, schlägt die Installation der Erweiterung fehl und das Verzeichnis wird aufgeräumt.

+++ Die "onUninstall"-Funktion +++
NVDA sucht eine Funktion "onUninstall" in der Python-Datei "installTasks.py" und führt sie aus, wenn NVDA neu gestartet wird, nachdem der Benutzer sich entschieden hat, die Erweiterung zu entfernen.
Nach Abschluss dieser Funktion wird das Verzeichnis der Erweiterung automatisch entfernt.
Da dies beim NVDA-Start geschieht, bevor andere Komponenten initialisiert werden, kann diese Funktion keine Eingaben vom Benutzer anfordern.

++ Erweiterungen übersetzen ++
Es ist möglich, lokal spezifische Informationen und Meldungen für Ihre Erweiterung bereitzustellen.
Lokale Informationen können im Verzeichnis "locale" im Archiv gespeichert werden.
Dieses Verzeichnis sollte Unterverzeichnisse für jede unterstützte Sprache enthalten, wobei das gleiche Format für die Sprach-Codes in NVDA verwendet wird; z. B. "en" für Englisch, "fr_CA" für kanadisches Französisch.

+++ Manifest-Dateien übersetzen +++
Jedes dieser Sprachverzeichnisse kann eine sprachspezifische Manifest-Datei mit dem Namen "manifest.ini" enthalten, die zu übersetzenden Felder des Manifests enthalten kann.
Diese Felder sind "summary" und "description".
Alle anderen Felder werden ignoriert.

+++ Sprachspezifische Meldungen +++
Jedes Sprachverzeichnis kann auch Informationen (gettext) enthalten, mit denen das System den Rest der NVDA-Benutzeroberfläche und die gemeldeten Meldungen übersetzt.
Wie in NVDA selbst sollte eine kompilierte Datenbankdatei (gettext) mit dem Namen "nvda.mo" im Verzeichnis "LC_MESSAGES" innerhalb dieses Verzeichnisses abgelegt werden.
Damit Module in Ihrer Erweiterung über Aufrufe von _() auf Informationen der Meldungen (gettext) zugreifen können, müssen Sie die Übersetzungen am Anfang jedes Python-Moduls durch den Aufruf der Funktion "addonHandler.initTranslation()" initialisieren.
Für weitere Informationen zu "gettext" und die NVDA-Übersetzung im Allgemeinen lesen Sie bitte den Wiki-Artikel unter https://github.com/nvaccess/nvda/wiki/Translating von NV Access auf GitHub.

++ Dokumentation zur Erweiterung ++[AddonDoc]
Die Dokumentation zu einer Erweiterung sollte im Verzeichnis "doc" im Archiv abgelegt werden.
Ähnlich wie das Verzeichnis "locale" sollte dieses Verzeichnis auch Unterverzeichnisse für jede Sprache enthalten, in der die Dokumentation verfügbar ist.

Benutzer können auf die Dokumentation zu einer bestimmten Erweiterung zugreifen, indem sie den Menüpunkt "Erweiterungen verwalten" aus dem Untermenü "Werkzeuge" im NVDA-Menü öffnen, die ERweiterung auswählen und auf den Schaltfläche "Hilfe" klicken.
Dadurch wird die im Parameter "docFileName" der Manifest-Datei benannte Datei geöffnet.
NVDA wird diese Datei in den entsprechenden Sprachverzeichnissen suchen.
Wenn zum Beispiel der Parameter "docFileName" auf die Datei "readme.html" gesetzt ist und der Benutzer Englisch benutzt, öffnet NVDA "doc\en\readme.html".

+ NVDA-Python-Konsole +[PythonConsole]
Die NVDA-Python-Konsole emuliert den interaktiven Python-Interpreter aus NVDA heraus.
Es ist ein Entwicklungswerkzeug, das für das Debugging, die allgemeine Inspektion von NVDA-Interna oder die Inspektion der Accessibility-Hierarchie einer Anwendung nützlich ist.

++ Verwendung ++
Die Konsole kann auf zwei Arten aktiviert werden:
- Durch Drücken von NVDA+Strg+Z.
Wenn auf diese Weise aktiviert, wird eine Momentaufnahme des aktuellen Zustands von NVDA zum Zeitpunkt des Tastendrucks erstellt und in der Konsole in bestimmten Variablen gespeichert.
Für weitere Informationen lesen Sie im Abschnitt [Snapshot-Variablen #PythonConsoleSnapshotVariablen].
- Aus dem NVDA-Menü "Werkzeuge" -> "Python-Konsole".
-

Die Konsole ist dem interaktiven Standard-Python-Interpreter ähnlich.
Die Eingabe wird zeilenweise übernommen und mit der Enter-Taste verarbeitet.
Mehrere Zeilen können auf einmal aus der Zwischenablage eingefügt werden und werden nacheinander abgearbeitet.
Mit den Pfeiltasten nach oben und unten können Sie durch den Verlauf der zuvor eingegebenen Zeilen navigieren.

Die Ausgabe (Rückmeldung des Interpreters) wird vorgelesen, wenn die Eingabetaste betätigt wird.
Die Taste F6 schaltet zwischen der Ein- und Ausgabe hin und her.

Das Ergebnis des zuletzt ausgeführten Befehls wird in der globalen Variable "_" gespeichert.
Damit wird die Funktion "gettext", die als gleichnamiger BuiltIn-Funktion gespeichert ist, kopiert.
Sie kann durch Ausführung von "del _" gelöst und durch Ausführung von "_ = _" ganz vermieden werden.

Durch Schließen des Konsolenfensters (mit Escape oder Alt+F4) wird es einfach ausgeblendet.
Dadurch kann der Benutzer zu der Sitzung zurückkehren, wie er sie beim Schließen verlassen hat, einschließlich des Verlaufs und der Variablen.

++ Namensraum in der Python-Konsole ++[PythonConsoleNamespace]

+++ Automatisches Importieren +++
Die folgenden Module und Variablen werden der Einfachheit halber automatisch in die Konsole importiert:
sys, os, wx, log (from logHandler), api, queueHandler, speech, braille

+++ Snapshot-Variablen +++[PythonConsoleSnapshotVariables]
Immer wenn NVDA+Strg+Z gedrückt wird, werden in der Konsole bestimmte Variablen entsprechend dem aktuellen Zustand von NVDA zugewiesen.
Diese Variablen sind:
- focus: Das aktuelle Fokus-Objekt.
- focusAnc: Die Familie des aktuellen Fokus-Objekts.
- fdl: Fokus-Differenz-Stufe; d. h. das Level, auf der sich die Familie für den aktuellen und den vorherigen Fokus unterscheiden.
- fg: Das aktuelle Objekt im Vordergrund.
- nav: Das aktuelle navigator-Objekt.
- mouse: Das aktuelle Maus-Objekt.
- brlRegions: Die Braille-Regionen aus dem aktiven Braille-Puffer.
-

++ Tab-Vervollständigung ++
Damit wird die Tabulator-Vervollständigung von Variablen und Namen der Attribute unterstützt.
Drücken Sie einmal die Tabulator-Taste, um die aktuelle Eingabe abzuschließen, wenn es nur einen einzigen Kandidaten gibt.
Wenn es mehr als eine gibt, drücken Sie die Tabulator-Taste ein zweites Mal, um ein Auswahlmenü mit allen passenden Möglichkeiten zu erhalten.
Standardmäßig werden nur "öffentliche" Attribute aufgelistet.
Lautet die Eingabe "nav.", werden Namen der Attribute ohne führenden Unterstrich vorgeschlagen.
Lautet die Eingabe "nav._", werden Namen der Attribute mit einem einfachen führenden Unterstrich vorgeschlagen.
Ebenso werden bei der Eingabe "nav.__" Namen der Attribute mit zwei führenden Unterstrichen vorgeschlagen.

+ Remote-Python-Konsole +
Für Situationen, in denen ein Remote-Debugging von NVDA hilfreich ist, steht eine Remote-Python-Konsole zur Verfügung.
Sie ist ähnlich der lokalen [Python-Konsole #PythonConsole], wird aber über TCP angesprochen.

Bitte beachten Sie, dass dies ein großes Sicherheitsrisiko darstellt!
Sie sollten sie nur aktivieren, wenn Sie sich in vertrauenswürdigen Netzwerken befinden.

++ Verwendung ++
Um die Remote-Python-Konsole zu aktivieren, verwenden Sie die lokale Python-Konsole, um "remotePythonConsole" zu importieren und "remotePythonConsole.initialize()" aufzurufen.
Sie können sich dann über den TCP-Port 6832 darüber verbinden.

Der Verlauf von zuvor eingegebenen Zeilen wird dabei nicht unterstützt.

Der Namensraum ist der gleiche wie der [Namensraum in der Python-Konsole #PythonConsoleNamespace].

Es gibt einige spezielle Funktionen:
- snap(): Erstellt einen Schnappschuss des aktuellen Zustands von NVDA und speichert ihn in den [Snapshot-Variablen #PythonConsoleSnapshotVariables].
- rmSnap(): Entfernt alle Snapshot-Variablen.
-
